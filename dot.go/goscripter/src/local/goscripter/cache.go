package goscripter

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"github.com/BurntSushi/toml"
)

func readManifest(p string) (Manifest, error) {
	var m Manifest
	if !fileExists(p) {
		return m, os.ErrNotExist
	}
	_, err := toml.DecodeFile(p, &m)
	return m, err
}
func writeManifest(p string, m Manifest) error {
	var buf bytes.Buffer
	if err := toml.NewEncoder(&buf).Encode(m); err != nil {
		return err
	}
	return os.WriteFile(p, buf.Bytes(), 0o644)
}
func mtimeUnix(p string) int64 {
	fi, err := os.Stat(p)
	if err != nil {
		return 0
	}
	return fi.ModTime().Unix()
}
func flagsEqual(a, b []string) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}
func sliceEqual(a, b []string) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

func analyzeCache(scriptAbs, cacheDir string, flags []string, env mergedEnv) cacheDecision {
	manPath := filepath.Join(cacheDir, manifestName)
	binPath := filepath.Join(cacheDir, cacheBinName)
	m, err := readManifest(manPath)
	dec := cacheDecision{rebuild: false, reasons: []string{}, man: m, cacheDir: cacheDir}
	dec.buildCmd = fmt.Sprintf("go build -C %s -o %s %s", cacheDir, cacheBinName, strings.Join(flags, " "))
	dec.buildEnvM = "GO111MODULE=" + env.GO111MODULE
	dec.buildEnvP = "GOPATH=" + strings.Join(env.GOPATH, string(os.PathListSeparator))

	if fi, e := os.Stat(binPath); e == nil {
		dec.binOK = true
		dec.binMTime = fi.ModTime()
	}

	if err != nil {
		dec.rebuild = true
		dec.reasons = append(dec.reasons, "manifest missing")
	}
	if !dec.binOK {
		dec.rebuild = true
		dec.reasons = append(dec.reasons, "binary missing")
	}
	if err == nil && m.SourceMTime != mtimeUnix(scriptAbs) {
		dec.rebuild = true
		old := time.Unix(m.SourceMTime, 0).Format(time.RFC3339)
		new := time.Unix(mtimeUnix(scriptAbs), 0).Format(time.RFC3339)
		dec.reasons = append(dec.reasons, "source mtime changed: "+old+" -> "+new)
	}
	if err == nil && !flagsEqual(m.Flags, flags) {
		dec.rebuild = true
		dec.reasons = append(dec.reasons, "build flags changed")
	}
	if err == nil {
		if m.EnvGO111MODULE != env.GO111MODULE {
			dec.rebuild = true
			dec.reasons = append(dec.reasons, "GO111MODULE changed: "+m.EnvGO111MODULE+" -> "+env.GO111MODULE)
		}
		if !sliceEqual(m.EnvGOPATH, env.GOPATH) {
			dec.rebuild = true
			dec.reasons = append(dec.reasons, "GOPATH changed")
		}
	} else {
		dec.reasons = append(dec.reasons, "env not recorded (first build)")
	}

	// Deps & toolchain comparison (only if we have snapshot)
	depsPath := filepath.Join(cacheDir, depsSnapshotName)
	if fileExists(depsPath) && fileExists(filepath.Join(cacheDir, modifiedSrcName)) {
		oldSnap, e1 := readDepsSnapshot(depsPath)
		if e1 == nil {
			curSnap := currentDepsSnapshot(cacheDir, env, flags, filepath.Dir(scriptAbs))
			if ch, rs := compareToolchain(oldSnap, curSnap); ch {
				dec.rebuild = true
				dec.reasons = append(dec.reasons, rs...)
			}
			if ch, rs := compareDeps(oldSnap, curSnap); ch {
				dec.rebuild = true
				dec.reasons = append(dec.reasons, rs...)
			}
		}
	}
	return dec
}

func produceModifiedSource(scriptAbs, outPath string) error {
	b, err := os.ReadFile(scriptAbs)
	if err != nil {
		return err
	}
	raw := b
	if bytes.HasPrefix(raw, []byte("#!")) {
		if idx := bytes.IndexByte(raw, '\n'); idx >= 0 {
			raw = raw[idx+1:]
		} else {
			raw = []byte{}
		}
	}
	var out bytes.Buffer
	out.WriteString("// Code generated by goscripter; DO NOT EDIT.\n")
	out.WriteString("//line " + scriptAbs + ":2\n")
	out.Write(raw)
	return os.WriteFile(outPath, out.Bytes(), 0o644)
}

func goBuild(cacheDir string, flags []string, env mergedEnv) error {
	envList := os.Environ()
	set := func(k, v string) {
		found := false
		for i := range envList {
			if strings.HasPrefix(envList[i], k+"=") {
				envList[i] = k + "=" + v
				found = true
				break
			}
		}
		if !found {
			envList = append(envList, k+"="+v)
		}
	}
	set("GO111MODULE", env.GO111MODULE)
	set("GOPATH", strings.Join(env.GOPATH, string(os.PathListSeparator)))

	args := []string{"build", "-C", cacheDir, "-o", cacheBinName}
	args = append(args, flags...)
	cmd := exec.Command("go", args...)
	cmd.Env = envList
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

// refreshCache also generates deps.toml on cache hits if missing
func refreshCache(op string, scriptAbs string, cb cacheBase, flags []string, env mergedEnv, verbose bool) (cacheDecision, error) {
	cdir := cacheDirFor(cb, scriptAbs)
	if err := ensureDir(cdir); err != nil {
		return cacheDecision{}, err
	}
	dec := analyzeCache(scriptAbs, cdir, flags, env)
	if dec.rebuild {
		if verbose {
			fmt.Printf("%s: rebuild needed:\n", op)
			for _, r := range dec.reasons {
				fmt.Println("  -", r)
			}
			fmt.Printf("%s: build dir: %s\n", op, dec.cacheDir)
			fmt.Printf("%s: build env: %s\n", op, dec.buildEnvM)
			fmt.Printf("%s: build env: %s\n", op, dec.buildEnvP)
			fmt.Printf("%s: build cmd: %s\n", op, dec.buildCmd)
		}
		if err := produceModifiedSource(scriptAbs, filepath.Join(cdir, modifiedSrcName)); err != nil {
			return dec, fmt.Errorf("write modified source: %w", err)
		}
		if err := goBuild(cdir, flags, env); err != nil {
			return dec, fmt.Errorf("build failed: %w", err)
		}
		m := Manifest{
			SourceMTime:    mtimeUnix(scriptAbs),
			Flags:          append([]string{}, flags...),
			EnvGO111MODULE: env.GO111MODULE,
			EnvGOPATH:      append([]string{}, env.GOPATH...),
		}
		if err := writeManifest(filepath.Join(cdir, manifestName), m); err != nil && verbose {
			warnf("write manifest: %v", err)
		}
		if err := writeDepsSnapshot(cdir, env, flags, filepath.Dir(scriptAbs)); err != nil && verbose {
			warnf("write deps: %v", err)
		}
		dec = analyzeCache(scriptAbs, cdir, flags, env)
		if verbose {
			fmt.Printf("%s: cache rebuilt\n", op)
		}
	} else {
		depsPath := filepath.Join(cdir, depsSnapshotName)
		if !fileExists(depsPath) {
			if err := writeDepsSnapshot(cdir, env, flags, filepath.Dir(scriptAbs)); err != nil {
				if verbose {
					warnf("%s: deps snapshot missing; generation failed: %v", op, err)
				}
			} else if verbose {
				fmt.Printf("%s: deps snapshot missing; generated now\n", op)
			}
		}
		if verbose {
			fmt.Printf("%s: using cached binary\n", op)
			if dec.binOK {
				fmt.Printf("%s: cached binary mtime: %s\n", op, dec.binMTime.Format(time.RFC3339))
			}
		}
	}
	return dec, nil
}

func runFromCache(scriptAbs string, cb cacheBase, argv []string) int {
	cdir := cacheDirFor(cb, scriptAbs)
	exe := filepath.Join(cdir, cacheBinName)
	cmd := exec.Command(exe, argv...)
	cmd.Stdin = os.Stdin
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		if ee, ok := err.(*exec.ExitError); ok {
			return ee.ExitCode()
		}
		warnf("run error: %v", err)
		return 1
	}
	return 0
}
